<!DOCTYPE html>
<html>

<head>
<title>Dark Maze - Computational Geometry</title>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="js/jquery.js"></script>
</head>

<body>

<div class="container">
    <h1 class="title centered">
        Dark Maze
    </h1>
    <div>
        <h3> What is this website? </h3>
        <div>
            I implemented a computational geometry algorithm and turned it into a game. The object of the game is to nagivate your way around a <i>dark maze</i>,
            and when you get to the end, you have to get back to where you started.... faster than the time you took to get there. So make sure you remember your way as you
            navigate around!
            <br>
            You have a few seconds of memory to represent what you've just seen, but that disappears after a bit, so you have to remember your way around the polygon.
        </div>
    </div>
</div>

<div class="container">
    <div>Difficulty<span id="difficultytext"></span></div>
    <select id="difficulty">
        <option value="none" selected>Select a difficulty...</option>
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
    </select>
</div>

<div class="container">
    <div id="timer">
        <span id="minutes">00</span>:<span id="seconds">00</span>.<span id="ms">00</span>
    </div>
    <svg width="1024" height="768">
      <polygon class="maze" id="maze"/>
      <polygon class="visibility clickable" id="visibility"/>
      <circle r="10" id="end" class="endpoint"/>
      <circle r="5" id="player" class="player clickable"/>
    </svg>
</div>

<div class="container">
    <div>
        <h3> Visibility Polygons </h3>
        <div>
            The visibility polygon of a point with respect to a polygon is defined as all the points in the polygon that that point can "see". It's a pretty intuitive
            idea, but to implement a correct, general, fast algorithm to compute it is rather <a href="http://www.cs.tufts.edu/comp/163/lectures/163-chapter07.pdf">tricky</a>. 
        </div>
    </div>

    <br>

    <div><h3> An Alternative Algorithm </h3>
        <div>
            An alternate to this linear-time algorithm is explained <a href="http://ncase.me/sight-and-light/">here</a>. Essentially these are the steps:
            <ol>
                <li>
                Cast a ray from the point to all vertices and record the first collision (<i>O(n)</i> for each vertex to get all the collisions, 
                for a total runtime of <i>O(n&sup2;)</i>)
                </li>
                <li>
                For all collisions, create 2 more collisions by shooting another ray +/- 0.000001 radians (for the walls behind any vertex).
                </li>
                <li>
                Sort all the collisions (<i>O(n log n)</i>) to piece together the polygon.
                </li>
            </ol>
        </div>
    </div>

    <br>

    <div>
        <h3> Linear algorithm explanation </h3>
        <div>
            Essentially, here is how the algorithm works:
            <br>
            (You can visually follow along <a href="http://www.cs.tufts.edu/comp/163/lectures/163-chapter07.pdf">here</a>)

            <br>
            <br>

            We do 4 instances of an algorithm that finds the visibility of a 90 degree cone, and stitch the visibility
            polygons (at all 4 angles; 0, 90, 180, and 270) together.

            First, we find the two points in the polygon where the 90 degree cone intersects an edge and add the player's point and
            those intersection points to a stack. This can be done in linear time by just looping through all the edges and seeing
            if the visibility cone intersects with that edge.
            Then, (without loss of generality, assume the polygon faces CCW) we walk linearly along the edges in a CCW direction.
            Assuming a convex polygon, this is all we need to do. If it's not convex, we may have more cases to check for.
            However, while the edges still face in a CCW direction with respect to the player, we can keep adding them to the stack.
            <br>
            <br>
            If the polygon enters an "upwards backtrack" (denoted by if an edge points in a CW direction with respect to
            the player and goes away from the player), we ignore edges until the algorithm emerges from the upwards backtrack, going CCW again, but this time
            above the edge that caused the upwards backtrack. When we find the emerging edge, we add a new window edge starting from
            the edge before the one that caused the upwards backtrack and ending at the emergence point that just became visible
            after returning from the upwards backtrack. Then, we resume walking in a CCW fashion and keep adding
            to the stack.
            <br>
            <br>
            If the polygon enters a "downwards backtrack" (denoted by if an edge points in a CW direction with respect to
            the player and faces towards the player), then the edge causing the downwards backtrack is covering up some edges, and
            we pop the edges that are completely covered from the stack, and add a window edge that intersects with the edge that
            is only <i>partially</i> covered by the downwards backtrack. Then, we resume walking in a CCW fashion and keep adding
            to the stack.. 
            <br>
            <br>
            There are more cases for what the polygon can do (such as a downwards backtrack crossing a window, in which case we need
            to slightly modify the case we're dealing with), but these cases are better described on the class slides <a href="http://www.cs.tufts.edu/comp/163/lectures/163-chapter07.pdf">here</a>.

            <br>
            <br>
            When we reach the last intersection point, the stack represents the visibility polygon in a cone! Now we just need to
            calculate the visibility polygon 3 more times (after changing the angle by 90 degrees) and stitch it together,
            and we have the entire visibility region of that point.
            <br>
            <br>
            Clearly, this algorithm is linear with respect to the number of edges of the polygon, becauase it takes linear time
            to find the intersection points, and takes linear time to walk along the edge list of the polygon sequentially, and
            potentially push/pop edges to/from the stack (at most once per edge).
        </div>
    </div>

    <br>

    <div>
        <h3>Bugs I ran into</h3>
        <div>
            TODO
            <br>
            -point stack vs edge stack
            <br>
            -upwards backtrack upper bound
        </div>
    </div>

    <br>

    <div>
        <h3><a href="https://github.com/popcorncolonel/DarkMaze/blob/master/js/visibilityregion.js">Source code</a></h3>
    </div>
</div>

</body>

<script src="js/polygon.js"></script>
<script src="js/config.js"></script>
<script src="js/game.js"></script>
<script src="js/maze.js"></script>
<script src="js/player.js"></script>
<script src="js/visibilityregion.js"></script>

</html>
